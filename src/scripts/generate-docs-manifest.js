// scripts/generate-docs-manifest.js
/**
 * @typedef {import('vue').Component} Component
 * @typedef {import('./types').ComponentItem} ComponentItem
 * @typedef {import('./types').ExampleItem} ExampleItem
 *
 * @type {Object}
 * @property {string} lib - ES2015 or later to support Promises
 */
const { glob } = require('glob');
const fs = require('fs');
const path = require('path');

// Function to parse command-line arguments
function parseArgs() {
  const args = {};
  process.argv.slice(2).forEach(arg => {
    const [key, value] = arg.split('=');
    if (key.startsWith('--')) {
      args[key.substring(2)] = value || true; // Handle boolean flags or values
    }
  });
  return args;
}

const args = parseArgs();

// Default values:
// 1. projectRoot: Defaults to the current working directory (where npm run is executed)
//    This is the most reliable way to find the actual project root when the script
//    is located deep in node_modules.
// 2. componentsDirName/examplesDirName: These are relative to projectRoot.
// 3. manifestOutputPath: Defaults to 'src/docs-manifest.ts' within the projectRoot.

const projectRoot = args.root ? path.resolve(process.cwd(), args.root) : process.cwd();
const componentsDirName = args.componentsDir || 'src/components'; // Common Vue component path, relative to projectRoot
const examplesDirName = args.examplesDir || 'src/component-examples'; // Common Vue example path, relative to projectRoot
const manifestOutputPath = args.output ? path.resolve(process.cwd(), args.output) : path.resolve(projectRoot, 'src', 'docs-manifest.ts');

// Ensure the output directory exists
const outputDir = path.dirname(manifestOutputPath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

console.log(`--- Generating Docs Manifest for Vue App ---`);
console.log(`Project Root: ${projectRoot}`);
console.log(`Components Directory (relative to root): ${componentsDirName}`);
console.log(`Examples Directory (relative to root): ${examplesDirName}`);
console.log(`Manifest Output Path: ${manifestOutputPath}`);
console.log(`------------------------------------------`);


async function generateDocsManifest() {
  const allComponents = [];
  const allExampleComponents = [];

  // --- Process Components ---
  // The glob patterns are constructed using projectRoot and the relative component directory name
  const componentGlobPattern = path.join(projectRoot, componentsDirName, '**', '*.vue').replace(/\\/g, '/');
  const componentFiles = await glob(componentGlobPattern);

  for (const filePath of componentFiles) {
    // relativePathInDir: e.g., 'buttons/MyButton.vue' (relative to 'src/components')
    const relativePathInDir = path.relative(path.join(projectRoot, componentsDirName), filePath);
    const label = path.basename(filePath, '.vue');

    // Construct import path relative to the *generated manifest file itself*
    // This allows bundlers to resolve the import correctly from the manifest's location.
    const importPathRelativeToManifest = `./${path.relative(path.dirname(manifestOutputPath), filePath).replace(/\\/g, '/')}`;

    allComponents.push({
      type: 'component',
      label: label,
      relativePath: relativePathInDir.replace(/\\/g, '/'), // Unix-like paths for consistency
      importer: `() => import('${importPathRelativeToManifest}')`,
      rawImporter: `() => import('${importPathRelativeToManifest}?raw')`, // For raw source code
    });
  }

  // --- Process Example Components ---
  const exampleGlobPattern = path.join(projectRoot, examplesDirName, '**', '*.vue').replace(/\\/g, '/');
  const exampleFiles = await glob(exampleGlobPattern);

  for (const filePath of exampleFiles) {
    // relativePathInDir: e.g., 'buttons/MyButton.vue' (relative to 'src/component-examples')
    const relativePathInDir = path.relative(path.join(projectRoot, examplesDirName), filePath);
    const label = path.basename(filePath, '.vue');

    // Construct import path relative to the *generated manifest file itself*
    const importPathRelativeToManifest = `./${path.relative(path.dirname(manifestOutputPath), filePath).replace(/\\/g, '/')}`;

    allExampleComponents.push({
      type: 'example',
      label: label,
      relativePath: relativePathInDir.replace(/\\/g, '/'), // Unix-like paths for consistency
      importer: `() => import('${importPathRelativeToManifest}')`,
    });
  }

  // Generate the TypeScript file content
  const manifestContent = `
// This file is auto-generated by scripts/generate-docs-manifest.js
// Do not edit this file directly.

import type { ComponentItem, ExampleItem } from 'vue-atomic-docs/dist/types'; // Reference types from the installed package

export const components: ComponentItem[] = ${JSON.stringify(allComponents, null, 2).replace(/"importer": "(.+?)"/g, '"importer": $1').replace(/"rawImporter": "(.+?)"/g, '"rawImporter": $1')};

export const exampleComponents: ExampleItem[] = ${JSON.stringify(allExampleComponents, null, 2).replace(/"importer": "(.+?)"/g, '"importer": $1')};
`;

  fs.writeFileSync(manifestOutputPath, manifestContent);
  console.log(`âœ… Docs manifest generated successfully.`);
}

generateDocsManifest().catch(console.error);
